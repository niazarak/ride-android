/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.ride.android.ast;

import java.util.ArrayList;
import java.util.List;

public class Parser {

    static class ParseResult {
        final Expressions.ListExpr node;
        final int offset;

        ParseResult(Expressions.ListExpr expr, int offset) {
            this.node = expr;
            this.offset = offset;
        }
    }

    private static ParseResult parse(List<Tokenizer.Token> tokens, int offset, int depth) {
        Expressions.ListExpr list = new Expressions.ListExpr();
        int i = offset;
        while (i < tokens.size() && tokens.get(i).getType() != Tokenizer.TokenType.PAREN_CLOSE) {
            Tokenizer.Token<?> t = tokens.get(i);
            if (t.getType() == Tokenizer.TokenType.PAREN_OPEN) {
                ParseResult childResult = parse(tokens, i + 1, depth + 1);
                i = childResult.offset;
                list.add(childResult.node);
            } else if (t.getType() == Tokenizer.TokenType.NUMBER) {
                Tokenizer.Token<Integer> numberToken = t.as(Tokenizer.TokenType.NUMBER);
                Expressions.Int childNode = new Expressions.Int(numberToken.getValue());
                list.add(childNode);
            } else if (t.getType() == Tokenizer.TokenType.BOOLEAN) {
                Tokenizer.Token<Boolean> booleanToken = t.as(Tokenizer.TokenType.BOOLEAN);
                Expressions.Bool childNode = new Expressions.Bool(booleanToken.getValue());
                list.add(childNode);
            } else if (t.getType() == Tokenizer.TokenType.SYMBOL) {
                Tokenizer.Token<String> symbolToken = t.as(Tokenizer.TokenType.SYMBOL);
                String symbol = symbolToken.getValue();

                Expressions.Variable childNode = new Expressions.Variable(symbol);
                list.add(childNode);

            } else {
                throw new RuntimeException("Unknown token: " + t.toString());
            }
            i++;
        }
        return new ParseResult(list, i);
    }

    private static Expression transform(Expression expr, int depth) {
        if (!(expr instanceof Expressions.ListExpr)) {
            // basic stuff
            return expr;
        }
        Expressions.ListExpr listExpr = (Expressions.ListExpr) expr;
        if (listExpr.getAll().isEmpty()) {
            throw new RuntimeException("Empty list expression");
        }

        // check first expr
        Expression firstExpr = listExpr.get(0);
        if (firstExpr instanceof Expressions.Variable) {
            Expressions.Variable firstVar = (Expressions.Variable) firstExpr;
            switch (firstVar.name) {
                case "define": {
                    return transformToDefine(listExpr, depth);
                }
                case "lambda": {
                    return transformToLambda(listExpr, depth);
                }
                case "if": {
                    return transformToIf(listExpr, depth);
                }
                default: {
                    return transformToApplication(listExpr, depth);
                }
            }
        } else if (firstExpr instanceof Expressions.ListExpr) {
            return transformToApplication(listExpr, depth);
        }
        return expr;
    }

    private static Expression transformToApplication(Expressions.ListExpr listExpr, int depth) {
        List<Expression> args = new ArrayList<>();
        for (int i = 1; i < listExpr.getAll().size(); i++) {
            args.add(transform(listExpr.get(i), depth + 1));
        }
        return new Expressions.Application(transform(listExpr.get(0), depth + 1), args);
    }

    private static Expressions.IfExpr transformToIf(Expressions.ListExpr expr, int depth) {
        if (expr.getAll().size() != 4) {
            throw new RuntimeException("Incorrect condition: should have 3 children");
        }

        return new Expressions.IfExpr(
                transform(expr.get(1), depth + 1),
                transform(expr.get(2), depth + 1),
                transform(expr.get(3), depth + 1)
        );
    }

    private static Expressions.Definition transformToDefine(Expressions.ListExpr expr, int depth) {
        if (depth != 0) {
            throw new RuntimeException("Incorrect definition: should be top-level declaration");
        }
        if (expr.getAll().size() != 3) {
            throw new RuntimeException("Incorrect definition: should have 3 children");
        }
        if (!(expr.get(1) instanceof Expressions.ListExpr)) {
            throw new RuntimeException("Incorrect definition: should specify contract in list");
        }
        Expressions.ListExpr contract = (Expressions.ListExpr) expr.get(1);
        if (!(contract.get(0) instanceof Expressions.Variable)) {
            throw new RuntimeException("Incorrect definition: function name should be a symbol");
        }
        String name = ((Expressions.Variable) contract.get(0)).name;
        List<String> args = new ArrayList<>();
        for (int i = 1; i < contract.getAll().size(); i++) {
            if (!(contract.get(i) instanceof Expressions.Variable)) {
                throw new RuntimeException("Incorrect definition: function arg should be a symbol");
            }
            Expressions.Variable arg = (Expressions.Variable) contract.get(i);
            args.add(arg.name);
        }
        return new Expressions.Definition(name, args, transform(expr.get(2), depth + 1));
    }

    private static Expressions.Lambda transformToLambda(Expressions.ListExpr expr, int depth) {
        if (expr.getAll().size() != 3) {
            throw new RuntimeException("Incorrect lambda: should have 3 children");
        }
        if (!(expr.get(1) instanceof Expressions.ListExpr)) {
            throw new RuntimeException("Incorrect lambda: should specify contract in list");
        }
        Expressions.ListExpr contract = (Expressions.ListExpr) expr.get(1);
        List<String> args = new ArrayList<>();
        for (int i = 0; i < contract.getAll().size(); i++) {
            if (!(contract.get(i) instanceof Expressions.Variable)) {
                throw new RuntimeException("Incorrect lambda: function arg should be a symbol");
            }
            Expressions.Variable arg = (Expressions.Variable) contract.get(i);
            args.add(arg.name);
        }
        return new Expressions.Lambda(args, transform(expr.get(2), depth + 1));
    }

    static public List<Expression> parse(List<Tokenizer.Token> tokens) {
        tokens.add(0, Tokenizer.Token.makeToken(Tokenizer.TokenType.PAREN_OPEN, "("));
        tokens.add(Tokenizer.Token.makeToken(Tokenizer.TokenType.PAREN_CLOSE, ")"));
        ParseResult parseResult = parse(tokens, 0, 0);
        if (parseResult.offset != tokens.size()) {
            throw new RuntimeException("Invalid syntax");
        }
        List<Expression> nodes = ((Expressions.ListExpr) parseResult.node.get(0)).getAll();
        System.out.println("Parsed node: " + nodes.toString());

        for (int i = 0; i < nodes.size(); i++) {
            nodes.set(i, transform(nodes.get(i), 0));
        }
        System.out.println("Transformed node: " + nodes.toString());
        return nodes;
    }


    // for testing purposes
    public static void main(String[] args) {
        final String input = "((+) (is 2))(define (a) (if (== a 2) 2 3))";
        parse(Tokenizer.tokenize(input));
    }
}
