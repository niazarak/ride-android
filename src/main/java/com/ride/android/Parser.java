/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.ride.android;

import java.util.ArrayList;
import java.util.List;

public class Parser {
    public static class Expression {
    }

    public static class Application extends Expression {
        private final List<Expression> args;
        private Expression function;

        public Application(Expression function, List<Expression> args) {
            this.function = function;
            this.args = args;
        }

        public Expression getFunction() {
            return function;
        }

        public Expression getArg(int i) {
            return args.get(i);
        }

        public List<Expression> getArgs() {
            return args;
        }

        @Override
        public String toString() {
            return "App{" +
                    "function=" + function +
                    ", args=" + args +
                    '}';
        }
    }

    public static class Definition extends Expression {
        private final String name;
        private final List<String> args;
        private final Expression body;

        public Definition(String name, List<String> args, Expression body) {
            this.name = name;
            this.args = args;
            this.body = body;
        }

        @Override
        public String toString() {
            return "Def{" +
                    "name='" + name + '\'' +
                    ", args=" + args +
                    ", body=" + body +
                    '}';
        }
    }

    public static class Lambda extends Expression {
        private final List<String> args;
        private final Expression body;

        public Lambda(List<String> args, Expression body) {
            this.args = args;
            this.body = body;
        }

        @Override
        public String toString() {
            return "Lambda{" +
                    "args=" + args +
                    ", body=" + body +
                    '}';
        }
    }

    public static class IfExpr extends Expression {
        final Expression condition, ifBranch, elseBranch;

        public IfExpr(Expression condition, Expression ifBranch, Expression elseBranch) {
            this.condition = condition;
            this.ifBranch = ifBranch;
            this.elseBranch = elseBranch;
        }

        @Override
        public String toString() {
            return "IfExpr{" +
                    "condition=" + condition +
                    ", ifBranch=" + ifBranch +
                    ", elseBranch=" + elseBranch +
                    '}';
        }
    }

    public static class Int extends Expression {
        public final int number;

        public Int(int number) {
            this.number = number;
        }

        @Override
        public String toString() {
            return "Int{" + number + '}';
        }
    }

    public static class Bool extends Expression {
        public final boolean value;

        public Bool(boolean value) {
            this.value = value;
        }

        @Override
        public String toString() {
            return "Bool{" + value + '}';
        }
    }

    public static class ListExpr extends Expression {
        List<Expression> expressions = new ArrayList<>();

        void add(Expression expression) {
            expressions.add(expression);
        }

        List<Expression> getAll() {
            return expressions;
        }

        @Override
        public String toString() {
            return "ListExpr{" +
                    "expressions=" + expressions +
                    '}';
        }

        Expression get(int i) {
            return expressions.get(i);
        }
    }

    public static class Variable extends Expression {
        public final String name;

        public Variable(String symbol) {
            this.name = symbol;
        }

        @Override
        public String toString() {
            return "Var{" + name + '}';
        }
    }

    static class ParseResult {
        final ListExpr node;
        final int offset;

        ParseResult(ListExpr expr, int offset) {
            this.node = expr;
            this.offset = offset;
        }
    }

    private static ParseResult parse(List<Tokenizer.Token> tokens, int offset, int depth) {
        ListExpr list = new ListExpr();
        int i = offset;
        while (i < tokens.size() && tokens.get(i).getType() != Tokenizer.TokenType.PAREN_CLOSE) {
            Tokenizer.Token<?> t = tokens.get(i);
            if (t.getType() == Tokenizer.TokenType.PAREN_OPEN) {
                ParseResult childResult = parse(tokens, i + 1, depth + 1);
                i = childResult.offset;
                list.add(childResult.node);
            } else if (t.getType() == Tokenizer.TokenType.NUMBER) {
                Tokenizer.Token<Integer> numberToken = t.as(Tokenizer.TokenType.NUMBER);
                Int childNode = new Int(numberToken.getValue());
                list.add(childNode);
            } else if (t.getType() == Tokenizer.TokenType.BOOLEAN) {
                Tokenizer.Token<Boolean> booleanToken = t.as(Tokenizer.TokenType.BOOLEAN);
                Bool childNode = new Bool(booleanToken.getValue());
                list.add(childNode);
            } else if (t.getType() == Tokenizer.TokenType.SYMBOL) {
                Tokenizer.Token<String> symbolToken = t.as(Tokenizer.TokenType.SYMBOL);
                String symbol = symbolToken.getValue();

                Variable childNode = new Variable(symbol);
                list.add(childNode);

            } else {
                throw new RuntimeException("Unknown token: " + t.toString());
            }
            i++;
        }
        return new ParseResult(list, i);
    }

    private static Expression transform(Expression expr, int depth) {
        if (!(expr instanceof ListExpr)) {
            // basic stuff
            return expr;
        }
        ListExpr listExpr = (ListExpr) expr;
        if (listExpr.getAll().isEmpty()) {
            throw new RuntimeException("Empty list expression");
        }

        // check first expr
        Expression firstExpr = listExpr.get(0);
        if (firstExpr instanceof Variable) {
            Variable firstVar = (Variable) firstExpr;
            switch (firstVar.name) {
                case "define": {
                    return transformToDefine(listExpr, depth);
                }
                case "lambda": {
                    return transformToLambda(listExpr, depth);
                }
                case "if": {
                    return transformToIf(listExpr, depth);
                }
                default: {
                    return transformToApplication(listExpr, depth);
                }
            }
        } else if (firstExpr instanceof ListExpr) {
            return transformToApplication(listExpr, depth);
        }
        return expr;
    }

    private static Expression transformToApplication(ListExpr listExpr, int depth) {
        List<Expression> args = new ArrayList<>();
        for (int i = 1; i < listExpr.getAll().size(); i++) {
            args.add(transform(listExpr.get(i), depth + 1));
        }
        return new Application(transform(listExpr.get(0), depth + 1), args);
    }

    private static IfExpr transformToIf(ListExpr expr, int depth) {
        if (expr.getAll().size() != 3) {
            throw new RuntimeException("Incorrect condition: should have 3 children");
        }

        return new IfExpr(
                transform(expr.get(1), depth + 1),
                transform(expr.get(2), depth + 1),
                transform(expr.get(3), depth + 1)
        );
    }

    private static Definition transformToDefine(ListExpr expr, int depth) {
        if (depth != 0) {
            throw new RuntimeException("Incorrect definition: should be top-level declaration");
        }
        if (expr.getAll().size() != 3) {
            throw new RuntimeException("Incorrect definition: should have 3 children");
        }
        if (!(expr.get(1) instanceof ListExpr)) {
            throw new RuntimeException("Incorrect definition: should specify contract in list");
        }
        ListExpr contract = (ListExpr) expr.get(1);
        if (!(contract.get(0) instanceof Variable)) {
            throw new RuntimeException("Incorrect definition: function name should be a symbol");
        }
        String name = ((Variable) contract.get(0)).name;
        List<String> args = new ArrayList<>();
        for (int i = 1; i < contract.getAll().size(); i++) {
            if (!(contract.get(i) instanceof Variable)) {
                throw new RuntimeException("Incorrect definition: function arg should be a symbol");
            }
            Variable arg = (Variable) contract.get(i);
            args.add(arg.name);
        }
        return new Definition(name, args, transform(expr.get(2), depth + 1));
    }

    private static Lambda transformToLambda(ListExpr expr, int depth) {
        if (expr.getAll().size() != 3) {
            throw new RuntimeException("Incorrect lambda: should have 3 children");
        }
        if (!(expr.get(1) instanceof ListExpr)) {
            throw new RuntimeException("Incorrect lambda: should specify contract in list");
        }
        ListExpr contract = (ListExpr) expr.get(1);
        List<String> args = new ArrayList<>();
        for (int i = 0; i < contract.getAll().size(); i++) {
            if (!(contract.get(i) instanceof Variable)) {
                throw new RuntimeException("Incorrect lambda: function arg should be a symbol");
            }
            Variable arg = (Variable) contract.get(i);
            args.add(arg.name);
        }
        return new Lambda(args, transform(expr.get(2), depth + 1));
    }

    static public List<Expression> parse(List<Tokenizer.Token> tokens) {
        tokens.add(0, Tokenizer.Token.makeToken(Tokenizer.TokenType.PAREN_OPEN, "("));
        tokens.add(Tokenizer.Token.makeToken(Tokenizer.TokenType.PAREN_CLOSE, ")"));
        ParseResult parseResult = parse(tokens, 0, 0);
        if (parseResult.offset != tokens.size()) {
            throw new RuntimeException("Invalid syntax");
        }
        List<Expression> nodes = ((ListExpr) parseResult.node.get(0)).getAll();
        System.out.println("Parsed node: " + nodes.toString());

        for (int i = 0; i < nodes.size(); i++) {
            nodes.set(i, transform(nodes.get(i), 0));
        }
        System.out.println("Transformed node: " + nodes.toString());
        return nodes;
    }


    // for testing purposes
    public static void main(String[] args) {
        final String input = "((+) (is 2))(define (a) (lambda () 2))";
        parse(Tokenizer.tokenize(input));
    }
}
