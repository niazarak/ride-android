/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.ride.android;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

public class Parser {
    static class Node {
    }

    static class ListNode extends Node {
        private final List<Node> nodes = new ArrayList<>();

        public void addNode(Node node) {
            nodes.add(node);
        }

        public Node getChild(int i) {
            return nodes.get(i);
        }

        @Override
        public String toString() {
            return "ListNode{" +
                    "nodes=" + nodes +
                    '}';
        }
    }

    static class NumberNode extends Node {
        final int number;

        public NumberNode(int number) {
            this.number = number;
        }

        @Override
        public String toString() {
            return "NumberNode{" +
                    "number=" + number +
                    '}';
        }
    }

    static class SymbolNode extends Node {
        final String symbol;

        public SymbolNode(String symbol) {
            this.symbol = symbol;
        }

        @Override
        public String toString() {
            return "SymbolNode{" +
                    "symbol='" + symbol + '\'' +
                    '}';
        }
    }

    static class ParseResult {
        final ListNode node;
        final int offset;

        ParseResult(ListNode node, int offset) {
            this.node = node;
            this.offset = offset;
        }
    }

    private static ParseResult parse(List<Token> tokens, int offset) {
        ListNode node = new ListNode();
        int i = offset;
        while (i < tokens.size() && tokens.get(i).getType() != TokenType.PAREN_CLOSE) {
            Token<?> t = tokens.get(i);
            if (t.getType() == TokenType.PAREN_OPEN) {
                ParseResult childResult = parse(tokens, i + 1);
                i = childResult.offset;
                node.addNode(childResult.node);
            } else if (t.getType() == TokenType.NUMBER) {
                Token<Integer> numberToken = t.as(TokenType.NUMBER);
                NumberNode childNode = new NumberNode(numberToken.getValue());
                node.addNode(childNode);
            } else if (t.getType() == TokenType.SYMBOL) {
                Token<String> numberToken = t.as(TokenType.SYMBOL);
                SymbolNode childNode = new SymbolNode(numberToken.getValue());
                node.addNode(childNode);
            }
            i++;
        }
        return new ParseResult(node, i);
    }

    static Node parse(List<Token> tokens) {
        Node node = parse(tokens, 0).node.getChild(0);
        // System.out.println("Parsed node: " + node.toString());
        return node;
    }


    private static class TokenType<TVALUE> {
        private final String title;

        public TokenType(final String title) {
            this.title = title;
        }

        @Override
        public String toString() {
            return "#" + title;
        }

        public static final TokenType<String> PAREN_OPEN = new TokenType<String>("PAREN_OPEN") {
        };
        public static final TokenType<String> PAREN_CLOSE = new TokenType<String>("PAREN_CLOSE") {
        };
        public static final TokenType<Integer> NUMBER = new TokenType<Integer>("NUMBER") {
        };
        public static final TokenType<String> SYMBOL = new TokenType<String>("SYMBOL") {
        };
    }

    private static abstract class Token<R> {
        abstract TokenType<R> getType();

        abstract R getValue();

        public <SR> Token<SR> as(TokenType<SR> type) {
            return (Token<SR>) this;
        }

        @Override
        public String toString() {
            TokenType<R> type = getType();
            R value = getValue();
            return "Token{" + type + ", " + value + " }";
        }

        static <SR> Token<SR> makeToken(final TokenType<SR> type, final SR value) {
            return new Token<SR>() {
                @Override
                public TokenType<SR> getType() {
                    return type;
                }

                @Override
                public SR getValue() {
                    return value;
                }
            };
        }
    }

    private static boolean isNumber(final String rawToken) {
        return Pattern.compile("\\d+").matcher(rawToken).matches();
    }

    private static boolean isParenOpen(final String rawToken) {
        return rawToken.equals("(");
    }

    private static boolean isParenClose(final String rawToken) {
        return rawToken.equals(")");
    }

    static List<Token> tokenize(final String input) {
        // System.out.println("Initial input: " + input);
        // insert spaces & split
        final String[] rawTokens = input.replace("(", " ( ")
                .replace(")", " ) ")
                .split(" ");
        // System.out.println("Converted input: " + Arrays.toString(rawTokens));


        // parse into tokens
        final List<Token> tokens = new ArrayList<>(rawTokens.length);
        for (final String rawToken : rawTokens) {
            if (rawToken == null || rawToken.isEmpty()) {
                continue;
            }
            if (isNumber(rawToken)) {
                tokens.add(Token.makeToken(TokenType.NUMBER, Integer.parseInt(rawToken)));
            } else if (isParenOpen(rawToken)) {
                tokens.add(Token.makeToken(TokenType.PAREN_OPEN, rawToken));
            } else if (isParenClose(rawToken)) {
                tokens.add(Token.makeToken(TokenType.PAREN_CLOSE, rawToken));
            } else {
                tokens.add(Token.makeToken(TokenType.SYMBOL, rawToken));
            }
        }

        // System.out.println("Tokens: " + tokens);

        return tokens;
    }

    // for testing purposes
    public static void main(String[] args) {
        final String input = "(this (is an) (s expression 2))";
        parse(tokenize(input));
    }
}
